/* MoAn is a motif discovery tool for DNA sequences */
/* Copyright (C) 2006 Eivind Valen */

/* This program is free software; you can redistribute it and/or */
/* modify it under the terms of the GNU General Public License */
/* as published by the Free Software Foundation; either version 2 */
/* of the License, or (at your option) any later version. */

/* This program is distributed in the hope that it will be useful, */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* GNU General Public License for more details. */

/* You should have received a copy of the GNU General Public License */
/* along with this program; if not, write to the Free Software */
/* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. */

#ifndef _ANNEAL_H_
#define _ANNEAL_H_


#include "sesa.h"
#include "hittable.h"
#include "moan.h"

/* Cutoff types */
#define FIXED        0      /* Cutoff is a fixed value */
#define DYNAMIC      1      /* Cutoff is some percentage of maximum generated by WM (c * SUFFIX_MAX) */
#define RATIO        2      /* Cutoff is some percentage of perfect conservation for that WMLENGTH (c * 2 * WMLENGTH) */
#define ANNEALED     3      /* Cutoff is annealed, i.e. is part of the search */

/* Annealing schedule */
#define EXPONENTIAL  0      /* T(i) = T(i-1) * R, where T(END) = T(0)^(MAXIT)  */
#define LINEAR       1      /* T(i) = T(i-1) - C, where T(0) - i*C = T(END)    */

#define WM(ind)         search->wm[2 * ind + search->cur[ind]]    /* The selected WM */
#define NWM(ind)        search->wm[2 * ind + !search->cur[ind]]   /* The unselected WM  */
#define SWITCH_WM(ind)  search->cur[ind] = !search->cur[ind]      /* Switch between the two WMs */
#define WM_IND(pssm, X, Y)     (pssm->offsets[X] + Y) 

/* #define HITS(ind)       search->hits[2 * ind + search->cur[ind]]    /\* The current hittable  *\/ */
#define HITS(ind)       search->hits[2 * ind + search->cur_hits[ind]]    /* The current hittable  */
#define SIZE(ind)       search->hittable_size[2 * ind + search->cur_hits[ind]]    /* Size of the current hittable  */
#define END(ind)        search->hittable_last[2 * ind + search->cur_hits[ind]]    /* The end of the current hittable */
#define SWITCH_HITS(ind)  search->cur_hits[ind] = !search->cur_hits[ind]      /* Switch between the two WMs */

typedef struct AnnealSearch {
  SESA sesa;                          /* Suffix Array */
  PSSM  *wm;                          /* WMs */  
  unsigned int pssm_count;            /* Number of WMs */
  char **setfiles;                    /* Name of the positive and negative set */
  /* Double stranded search*/
  PSSM  ds_tmp;                       /* Used as a temporary wm in double stranded mode */  
  unsigned int *fwd;                  /* Hit count on the forward strand */
  /* Annealing data */
  unsigned int *cur;                  /* Current WM */
  unsigned int *cur_hits;             /* Current HitTable */
  int *last_step;                     /* Last step performed on WM */
  double pos_score;                   /* Current score for positive set */
  double neg_score;                   /* Current score for negative set */
  unsigned int max_len;               /* Maximum length of the motifs */
  unsigned int min_len;               /* Minimum length of the motifs */
  /* Search parameters */
  float *wmpriors;                    /* Prior on WM lengths (if using bayesian scoring */
  float start_temp;                   /* Start temperature */
  float end_temp;                     /* End temperature */
  int ds;                             /* Wheter to search both strands */
  int cooc;                           /* Wheter to search for co-occurrence */
  float step_ratio;                   /* Ratio of temperature descent */
  unsigned int maxit;                 /* Maximum number of iterations */
  unsigned int loglevel;              /* Log level */
  unsigned int ctype;                 /* Type of cutoff: 0 = ratio, 1 = fixed */
  unsigned int schedule;              /* Annealing schedule LINEAR / EXPONENTIAL*/
  float *cut;                         /* The unmodified cutoff */
  float *cutoff;                      /* Modified cutoff (depending on ctype)*/
  unsigned int shared_cutoff;         /* Wheter cutoff is shared between the WMs */
  /* Search results */
  unsigned int best_step;             /* Step where the best score occured */
  float *best_cut;                    /* Cutoff for the best score attained */
  double best_score;                  /* Best score attained */
  double best_pos;                    /* Best score for the positive set */
  double best_neg;                    /* Best score for the negative set */
  int pos_matches;                    /* Matches in the positive set */
  int neg_matches;                    /* Matches in the negative set */
  int pos_cooc_matches;               /* Co-occuring matches in the positive set */
  int neg_cooc_matches;               /* Co-occuring matches in the negative set */
  unsigned int *match_count;          /* Number of matches pr WM */ 
  float **score;                      /* Score of matches pr WM pr match */
  struct HitTable **hits;
  struct HitEntry **hittable_last;
  int *hittable_size;
  unsigned int accrej;                /* Number of accepted steps since start */
  /* Saved data (for revert on rejects) */
  float *oldcut;                      /* Backup of cut (for annealed cutoff) */
  /* Searching functions */
  float (*scorefunc)(struct AnnealSearch *);              /* Function used for scoring */
  void  (*stepfunc)(struct AnnealSearch *, int , float);  /* Function used for stepping */
  /* Priors */
  float posnone;                      /* Prior on no occurrence in the positive set */
  float posone;                       /* Prior on one occurrence in the positive set */
  float poscooc;                      /* Prior on co-occurrence in the positive set */
  float negnone;                      /* Prior on no occurrence in the negative set */
  float negone;                       /* Prior on one occurrence in the negative set */
  float negcooc;                      /* Prior on co-occurrence in the negative set */
} Annealing;


#define PROB_INC_L       ((float) 0.05)
#define PROB_INC_R       ((float)(PROB_INC_L + 0.05))
#define PROB_DEC_L       ((float)(PROB_INC_R + 0.05))
#define PROB_DEC_R       ((float)(PROB_DEC_L + 0.05))
#define PROB_MOV_L       ((float)(PROB_DEC_R + 0.05))
#define PROB_MOV_R       ((float)(PROB_MOV_L + 0.05))
#define PROB_CUT         ((float)(PROB_MOV_R + 0.05))

/* Anneal functions */
float anneal(Annealing *search);
float anneal_step(Annealing *search, float temperature, float score);

/* Modification */
void wm_steal(Annealing *search, int wm_index, float temperature);

/* Memory */
void init_annealing(Annealing *anneal, int wmcount, PSSM *wm, int total);
void free_annealing(Annealing *anneal);

/* Div */
void create_logtable(int seq);
void print_pos_hits(SESA sesa, struct HitTable *hits, int wm_length);
PSSMSet load_matrices(char *filename, unsigned int min_length, unsigned int max_length, unsigned int alphlen, unsigned int total);
PSSMSet random_pssmset(unsigned int count, const unsigned char order,  const unsigned char min_length, const unsigned char max_length, const unsigned char alphlen, const int seq);

#endif
