#!/usr/bin/env python
# Copyright (c) 2009-2010 Simon van Heeringen <s.vanheeringen@ncmls.ru.nl>
#
# This module is free software. You can redistribute it and/or modify it under 
# the terms of the MIT License, see the file COPYING included with this 
# distribution.

from motiftools.motif import *
from motiftools.fasta import Fasta
from optparse import OptionParser
from numpy import *
from scipy.stats import wilcoxon,ranksums
import sys

VERSION = "0.1"
DEFAULT_BIN = 10
DEFAULT_CF_CUTOFF = 4
DEFAULT_REGION = "300:500"

def get_bins(coords, bins=50, range_max=500):
	coords = array(coords)
	bins,edges = histogram(coords, bins=bins, range=(0,range_max))
	return bins,edges

def get_cf(bins, edges, range):
	# Define filter based on specified range
	filter = logical_and(edges >= range[0], edges <= range[1])
	# This fall within the testing range, check the max of this region
	xmax = max(bins[filter])
	# This falls outside the testing range, calculate mean and std dev
	xmean = mean(bins[logical_not(filter)])
	s = std(bins[logical_not(filter)])
	return (xmax - xmean) / s

def get_wilcox_p(bins, edges, range):
	#Define filter based on specified range
	filter = logical_and(edges >= range[0], edges <= range[1])
	#print ",".join([str(x) for x in bins[filter]])
	#print ",".join([str(x) for x in bins[logical_not(filter)]])
	p = ranksums(bins[filter], bins[logical_not(filter)])
	#print p
	return p[1]

def get_scanning_wilcox_p(bins, edges, range):
	#Define filter based on specified range
	ps = []
	for i in arange(300, 400, 10):
		pos = bins[logical_and(edges >= i, edges < i + 100)]
		neg = bins[edges < 250]
		if mean(pos) > mean(neg):
			p = ranksums(pos, neg)[1]
			ps.append(p)
	#print ps
	if len(ps) > 0:
		return min(ps) * (len(ps) - 1)
	else:	
		return 1

def get_max_wilcox_p(bins, edges, range):
	m = max(bins[edges >= 300])
	max_pos = edges[logical_and(edges >= 300, bins == m)][0]
	#print "range: ",  (max_pos - 50), (max_pos + 50)	
	pos = bins[logical_and(edges >= (max_pos - 50), edges <= (max_pos + 50))]
	neg = bins[edges < (max_pos - 50)]
	return ranksums(pos, neg)[1]


parser = OptionParser(version="%prog " + VERSION)
parser.add_option("-f", "--fastafile", dest="fastafile", help="Sequences in FASTA format", metavar="FILE")
parser.add_option("-p", "--pwmfile", dest="pwmfile", help="Motifs in PWM format", metavar="FILE")
parser.add_option("-b", "--binsize", dest="binsize", help="Bin size (default %s)" % DEFAULT_BIN, metavar="FILE", default=DEFAULT_BIN)
parser.add_option("-c", "--cfcutoff", dest="cf_cutoff", help="Clustering factor cutoff (default %s)" % DEFAULT_CF_CUTOFF, metavar="FILE", default=DEFAULT_CF_CUTOFF, type="float")
parser.add_option("-r", "--cfregion", dest="cf_region", help="Region to check (start:end, default %s)" % DEFAULT_REGION, metavar="FILE", default=DEFAULT_REGION)
parser.add_option("--consensus", dest="consensus", help="Use consensus instead of pwm (default disabled)", default=False, action="store_true")

(options, args) = parser.parse_args()

if not options.pwmfile or not options.fastafile:
	parser.print_help()
	sys.exit()

range = options.cf_region.split(":")
range = int(range[0]), int(range[1])

# Load fasta file
fa = Fasta(options.fastafile)

# Get sequence length (based on the first sequence)
seqlen = len(fa.seqs[0])

# Load motifs
motifs = pwmfile_to_motifs(options.pwmfile)
#motifs = [m for m in motifs if m.id == "Meme_9_w7"]
#motifs += [x.rc() for x in motifs]

for motif in motifs:
	print motif
	# get matching positions
	positions = []	
	if options.consensus:
		for vals in motif.consensus_scan(fa).values():
			positions += vals
	else:
		for vals in motif.pwm_scan(fa).values():
			positions += vals
	
	# get the histogram/binning data
	bins, edges = get_bins(positions, bins=seqlen / options.binsize, range_max=seqlen)
	edges = edges[:-1] + (edges[1] - edges[0]) / 2
	
	# calculate the clustering factor
	p = get_scanning_wilcox_p(bins, edges, range) * len(motifs)
	#print "Scanning p", p
	#p = get_wilcox_p(bins, edges, range)
	#print "Wilcox p", p
	#p = get_max_wilcox_p(bins, edges, range)
	#print "Max Wilcox p", p
	cf = get_cf(bins, edges, range)
	if p <= options.cf_cutoff:
		print ">%s_%s\t%s\t%0.4e\n%s" % (motif.id, motif.to_consensus(), cf, p, "\n".join(motif.to_pwm().split("\n")[1:]))
	#print sys.exit()
