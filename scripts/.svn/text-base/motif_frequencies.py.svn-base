#!/usr/bin/env python
# Copyright (c) 2009-2010 Simon van Heeringen <s.vanheeringen@ncmls.ru.nl>
#
# This module is free software. You can redistribute it and/or modify it under 
# the terms of the MIT License, see the file COPYING included with this 
# distribution.

from motiftools.motif import *
from motiftools.fasta import Fasta
from optparse import OptionParser
from numpy import *
import sys

def get_length(fa):
	lengths = [len(x) for x in fa.seqs]
	counts = {}
	for l in lengths:
		counts[l] = counts.setdefault(l,0) + 1
	return sorted(counts.keys(), cmp=lambda x,y: cmp(counts[x], counts[y]))[-1]


def get_positions_window_scan(fa, motif, win, step):
	pos = []
	for seq,vals in motif.pwm_scan(fa, cutoff=0.95, scan_strand="+").items():
		pos += vals
	pos = array(pos)
	l = get_length(fa)
	x = []
	y = []
	for i in range(0, l - win + 1, step):
		x.append(i)
		y.append(sum(logical_and(pos >= i, pos < i + win - len(motif))))
	return x,y

def get_freqs_window_scan(fa, win, step):
	l = get_length(fa)
	data = array([array(list(x.upper())) for x in fa.seqs if len(x) == l])
	nucs = "ACGT"
	vals = {}
	for n in list(nucs):
		f = data == n
		v = [mean(sum(f[:,i : i + win],1)) / float(win) for i in range(0, l - win + 1, step)]
		vals[n] = v
	return vals

def get_normalized_motif_freq(motif, m_freq, nuc_freq, method="mult"):
	cons = motif.to_consensus()
		
	norm_freq = array([1] * len(m_freq), dtype=float)
	if method == "mean":
		norm_freq = array([0] * len(m_freq), dtype=float)
	
	for char in cons.upper():
		x = array([0] * len(m_freq), dtype=float)
		for nuc in motif.iupac[char]:
			x += nuc_freq[nuc]	
		if method == "mult":
			norm_freq *= x
		elif method == "mean":
			norm_freq += x
	
	if method =="mean":
		norm_freq /= len(cons)
	elif method == "mult":
		norm_freq /= 0.25 ** len(cons)
	#print motif
	#print norm_freq
	return m_freq / norm_freq 



VERSION = "0.1"
DEFAULT_WIN = 50
DEFAULT_STEP = 5

parser = OptionParser(version="%prog " + VERSION)
parser.add_option("-f", "--fastafile", dest="fastafile", help="Inputfile in FASTA format", metavar="FILE")
parser.add_option("-p", "--pwmfile", dest="pwmfile", help="Inputfile in PWM format", metavar="FILE")
parser.add_option("-n", "--normalize", dest="norm", help="Normalize to nucleotide frequencies", default=False, action="store_true")
parser.add_option("-r", "--include_rc", dest="rc", help="Include the reverse complement of the motif", default=False, action="store_true")
parser.add_option("-s", "--stepsize", dest="step", help="Step size (default %s)" % DEFAULT_STEP, metavar="INT", default=DEFAULT_STEP, type="int")
parser.add_option("-w", "--winsize", dest="win", help="Window size (default %s)" % DEFAULT_WIN, metavar="INT", default=DEFAULT_WIN, type="int")

(options, args) = parser.parse_args()

if not options.fastafile or not options.pwmfile:
	parser.print_help()
	sys.exit()

all_motifs = pwmfile_to_motifs(options.pwmfile)

fa = Fasta(options.fastafile)

step = options.step
win = options.win

if options.norm:
	nuc_freqs = get_freqs_window_scan(fa, win, step)

l = get_length(fa)

print "Motif\t%s" % "\t".join([str(x) for x in range(0, l - win + 1, step)])
for m in all_motifs:
	motifs = [m]
	if options.rc:
		motifs.append(m.rc())
	for motif in motifs:
		x,motif_freq = get_positions_window_scan(fa, motif, win, step)
	
		if options.norm:
			motif_freq = get_normalized_motif_freq(motif, motif_freq, nuc_freqs)
		print "%s\t%s" % (motif.id, "\t".join([str(x) for x in motif_freq]))	

